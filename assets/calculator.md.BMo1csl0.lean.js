import{_ as $,a4 as D,v as I,y as E,a5 as V,o as _,c as p,j as v,t as x,k as z,F as j,E as g,a6 as T,a7 as B,a as M,a8 as F,a9 as L,e as X,I as A}from"./chunks/framework.SWlRDSC1.js";const Z=["id"],q={key:0,type:"radio",disabled:""},Q=["value"],J=["colspan"],H=["onUpdate:modelValue"],K=["value"],Y=["readonly","onUpdate:modelValue"],ee={key:0},te={colspan:"999"},ne={style:{"text-align":"left"}},ae={__name:"CalculatorWidget",props:{config:{type:Object,required:!0}},setup(O){const f=O.config;function C(l){const u={};for(let n in l)u[n]=l[n].value;return u}function k(l){return typeof l=="number"?parseFloat(l.toFixed(4)):typeof l=="string"?l.toString().toUpperCase():l}function d(l,u){const n=Object.keys(u).length,c=l.reduce((t,i)=>Object.keys(i).length>t?Object.keys(i).length:t,-1/0);return n===1&&c!==1?c:void 0}const r=D({items:f.items,select:Object.values(f.items).filter(l=>!l.disabled).length>0?Object.values(f.items).filter(l=>!l.disabled)[0].name:void 0,info:void 0}),e=f.calc,o=(l,u)=>{console.log("updateValue",l,u);const n=C(u);if(l){const c=e(l,n);if(c&&typeof c=="object"){console.log("result",c);for(let t in c){if(t==="info"){r.info=c[t];continue}for(let i in c[t])n[t][i]=k(c[t][i]);u[t].readonly=!0}u[l].readonly=!1}console.log("updateValue after",n,u)}else r.info=e(void 0,n).info};return I([()=>r.select,()=>r.items],()=>{console.log("watch",r.select,r.items),o(r.select,r.items)},{immediate:!0,deep:!0}),E(()=>{console.log("mounted",f.name,{items:V(r.items),select:V(r.select)})}),(l,u)=>(_(),p(j,null,[v("h2",{id:z(f).name.toLowerCase().replaceAll(" ","-")},x(z(f).name),9,Z),v("table",null,[(_(!0),p(j,null,g(r.items,n=>(_(),p("tr",null,[v("td",null,[n.disabled?(_(),p("input",q)):T((_(),p("input",{key:1,type:"radio",value:n.name,"onUpdate:modelValue":u[0]||(u[0]=c=>r.select=c)},null,8,Q)),[[B,r.select]]),M(" "+x(n.name),1)]),(_(!0),p(j,null,g(n.value,(c,t)=>(_(),p("td",{colspan:d(Object.values(C(r.items)),n.value)},[Array.isArray(n.range[t])?T((_(),p("select",{key:0,"onUpdate:modelValue":i=>n.value[t]=i},[(_(!0),p(j,null,g(n.range[t],i=>(_(),p("option",{value:i},x(i),9,K))),256))],8,H)),[[F,n.value[t]]]):T((_(),p("input",{key:1,type:"number",readonly:n.readonly,"onUpdate:modelValue":i=>n.value[t]=i},null,8,Y)),[[L,n.value[t]]])],8,J))),256)),v("td",null,x(n.comment),1)]))),256)),r.info?(_(),p("tr",ee,[v("td",te,[v("pre",ne,x(r.info),1)])])):X("",!0)])],64))}},oe=$(ae,[["__scopeId","data-v-7a510a7a"]]),re={__name:"Calculator",setup(O){function a(d="default",r="默认注释",e=void 0,o=void 0,l=!1){switch(Object.prototype.toString.call(e)){case"[object Undefined]":e={value_:9999.9999},o={value_:{min:-9999.9999,max:9999.9999}};break;case"[object Number]":e={value_:e},Object.prototype.toString.call(o)==="[object Object]"&&o.min&&o.max||Object.prototype.toString.call(o)==="[object Array]"?o={value_:o}:o={value_:{min:-9999.9999,max:9999.9999}};break;case"[object String]":e={value_:e},Object.prototype.toString.call(o)==="[object String]"||Object.prototype.toString.call(o)==="[object Array]"?o={value_:o}:o={value_:"任何字符串"};break;case"[object Boolean]":e={value_:e},o={value_:[!1,!0]};break;case"[object Object]":e=e,o=o||{};for(const n in e)if(Object.hasOwnProperty.call(o,n))o[n]=o[n];else switch(Object.prototype.toString.call(e[n])){case"[object Number]":o[n]={min:-9999.9999,max:9999.9999};break;case"[object String]":o[n]="任何字符串";break;case"[object Boolean]":o[n]=[!1,!0];break}break;default:throw new Error("不支持的类型",e)}const u={name:d,comment:r,value:e,range:o||{min:-9999.9999,max:9999.9999},disabled:l};{let n;Array.isArray(e)?n=e:typeof e=="object"?n=[...Object.values(e).flat()]:n=[e],n.every(c=>typeof c=="boolean")?u.inType="boolean":n.every(c=>typeof c=="string")?u.inType="string":n.every(c=>typeof c=="number")&&(u.inType="number")}return u}function f(...d){const r={};return d.forEach(e=>{r[e.name]=e}),r}const C={CtypeChamfer:{name:"C 类型倒角切点计算",items:f(a("start","起始 X 和 Z 坐标",{x:0,z:0},void 0,!0),a("angle","与轴向 角度 A",45,{min:-359.9999,max:359.9999},!0),a("a","斜边长度",1,{min:0,max:9999.9999}),a("b","径向 U/2 长度"),a("c","轴向 W 长度"),a("end","终止 X 和 Z 坐标",{x:void 0,z:void 0},void 0,!0)),calc:(d,r)=>{const{start:e,angle:{value_:o},a:{value_:l},b:{value_:u},c:{value_:n},end:c}=r,t=m=>m*Math.PI/180,i=m=>Math.sin(t(m)),G=m=>Math.cos(t(m)),b=m=>Math.tan(t(m)),h=m=>Math.sqrt(m),s={},R={a:()=>(s.end={x:e.x+l*i(o)*2,z:e.z+l*G(o)},s.b={value_:(e.x+s.end.x)/2},s.c={value_:e.z+s.end.z},s),b:()=>(s.end={x:e.x+u*2,z:e.z+u/b(o)},s.c={value_:e.z+s.end.z},s.a={value_:h(u**2+s.c.value_**2)},s),c:()=>(s.end={x:e.x+n*b(o)*2,z:e.z+n},s.b={value_:(e.x+s.end.x)/2},s.a={value_:h(s.b.value_**2+n**2)},s)};if(d)return R[d]()}},ChamferCRC:{name:"倒角补偿计算",items:f(a("tRad","刀具刀尖半径 R",.4,[.2,.4,.6,.8,1],!0),a("cType","倒角类型","C型",["C型","R型外角","R型内角"],!0),a("cValue","倒角值",.4,void 0),a("W","补偿值 W",void 0,void 0,!0),a("U","补偿值 U",void 0,void 0,!0),a("C","补偿值 C",void 0,void 0,!0),a("R","补偿值 R",void 0,void 0,!0),a("cRad","C 型倒角处圆弧过渡半径",.4,void 0,!0),a("rW","圆弧过渡半径，补偿值 W",void 0,void 0,!0),a("rU","圆弧过渡半径，补偿值 U",void 0,void 0,!0)),calc:(d,r)=>{const{tRad:{value_:e},cType:{value_:o},cValue:{value_:l},cRad:{value_:u},rW:{value_:n},rU:{value_:c}}=r,t={},i=(b,h,s=45)=>{const R=y=>y*(Math.PI/180),m=y=>Math.tan(R(y)),U=y=>Math.sin(R(y)),P=y=>Math.cos(R(y)),W=(90-s)/2,w=U(W)*2*(h+b),N=U(W)*w,S=(P(W)*w-m(s)*N)*2;return{rW:N,rU:S}},G={cValue:()=>{switch(o){case"C型":t.W={value_:l+e*.586},t.U={value_:t.W.value_*2},t.C={value_:t.W.value_},t.R={value_:void 0},t.rW={value_:i(e,u).rW},t.rU={value_:i(e,u).rU};break;case"R型外角":t.W={value_:l+e},t.U={value_:t.W.value_*2},t.C={value_:void 0},t.R={value_:t.W.value_},t.cRad={value_:void 0},t.rW={value_:void 0},t.rU={value_:void 0};break;case"R型内角":t.W={value_:l-e},t.U={value_:t.W.value_*2},t.C={value_:void 0},t.R={value_:t.W.value_},t.cRad={value_:void 0},t.rW={value_:void 0},t.rU={value_:void 0};break}return t}};if(d)return G[d]()}},CrcCommand:{name:"FANUC 刀尖半径补偿设定 G10",items:f(a("tDir","刀架方位","后置",["前置","后置"],!0),a("cPos","切削位置","外径",["外径","内径","端面","侧面"],!0),a("cDir","切削方向","←",["←","→","↑","↓"],!0),a("tNum","刀具号 T",9,{min:1,max:99},!0),a("tRad","刀具刀尖半径 R",.4,[.2,.4,.6,.8,1],!0),a("tNos","刀尖方位号 Q",2,[0,1,2,3,4,5,6,7,8,9],!0)),calc:(d,r)=>{const{tDir:{value_:e},cPos:{value_:o},cDir:{value_:l},tNum:{value_:u},tRad:{value_:n},tNos:{value_:c}}=r,t={},i={};i.后置=[[2," 6 ",1],[7,"0/9",5],[3," 8 ",4]],i.前置=[...i.后置].reverse();const b={前置:{外径:{"←":"G41","→":"G42","↑":"G40","↓":"G40"},内径:{"←":"G42","→":"G41","↑":"G40","↓":"G40"},端面:{"←":"G40","→":"G40","↑":"G41","↓":"G42"},侧面:{"←":"G40","→":"G40","↑":"G42","↓":"G41"}},后置:{外径:{"←":"G42","→":"G41","↑":"G40","↓":"G40"},内径:{"←":"G41","→":"G42","↑":"G40","↓":"G40"},端面:{"←":"G40","→":"G40","↑":"G42","↓":"G41"},侧面:{"←":"G40","→":"G40","↑":"G41","↓":"G42"}}}[e][o][l];return t.info=`当前机器刀架为：${e}。

刀尖方位号参考图：
${i[e].map(h=>h.join(" ")).join(`
`)}

可用指令：
1. G10 P${u} R0 Q0 (设置磨损偏置)；
2. G10 P${u+1e4} R${n} Q${c} (设置几何偏置)；
3. ${b} (刀尖半径补偿指令)。

提示：
1. 首先在数控系统的形状设置界面中，分别设置 T（刀具方位号） 和 R（刀具刀尖半径）；
2. 还要记得检查补偿设置界面中，T（刀具方位号） 和 R（刀具刀尖半径）是否为零，如果不是，将其设置为零；
3. 在编程在使用刀尖半径补偿指令（G41、G42），需要考虑将切削路径的 切入 和 切出 线段延长至少一个刀尖半径值，当前为： ${n} 。
`,console.log(t),t}},Tolerance:{name:"尺寸公差",items:f(a("basic","基本公差",62,void 0),a("upper","上公差",.05,void 0,!0),a("lower","下公差",-.05,void 0,!0),a("maximum","上限尺寸",void 0,void 0,!0),a("nominal","中值尺寸",void 0,void 0,!0),a("minimum","下限尺寸",void 0,void 0,!0)),calc:(d,r)=>{const{basic:{value_:e},upper:{value_:o},lower:{value_:l}}=r,u={};return d==="basic"&&(u.maximum={value_:e+o},u.nominal={value_:e+(o+l)/2},u.minimum={value_:e+l}),u}},Groove:{name:"矩形沟槽",items:f(a("type","沟槽类型","OD",["OD","ID","FACE"],!0),a("start","起始 X 和 Z 坐标",{x:0,z:0},void 0,!0),a("end","终止 X 和 Z 坐标",{x:0,z:0},void 0),a("size","槽宽 和 槽深",{width:0,depth:0},{depth:{min:.009,max:9999.9999}}),a("leftTopChamfer","左侧上部倒角",{type:"C 型",value:.4},{type:["C 型","R 型"]},!0),a("leftBottomChamfer","左侧下部倒角",{type:"C 型",value:.4},{type:["C 型","R 型"]},!0),a("rightTopChamfer","右侧上部倒角",{type:"C 型",value:.4},{type:["C 型","R 型"]},!0),a("rightBottomChamfer","右侧下部倒角",{type:"C 型",value:.4},{type:["C 型","R 型"]},!0),a("tWidth","刀具宽度",.4,{min:.009,max:9999.9999},!0),a("tRad","刀具刀尖半径",.4,[.2,.4,.6,.8,1],!0),a("tPos","刀具对刀点位置","LEFT",["LEFT","RIGHT","CENTER"],!0)),calc:(d,r)=>{const{type:{value_:e},start:o,end:l,size:u,leftTopChamfer:n,leftBottomChamfer:c,rightTopChamfer:t,rightBottomChamfer:i,tWidth:{value_:G},tRad:{value_:b},tPos:{value_:h}}=r,s={};return s.info=`沟槽类型：${e}。`,s}}};return(()=>{const d=[];Object.values(C).forEach(r=>{d.push({depth:2,slug:r.name.toLowerCase().replaceAll(" ","-"),text:r.name,children:[]})}),console.log(`creatAstroTableOfContents
`,JSON.stringify(d))})(),(d,r)=>(_(),p(j,null,g(C,(e,o)=>A(oe,{config:e},null,8,["config"])),64))}},le=v("h1",{id:"calculator",tabindex:"-1"},[M("Calculator "),v("a",{class:"header-anchor",href:"#calculator","aria-label":'Permalink to "Calculator"'},"​")],-1),ue=v("p",null,"This is a calculator component.",-1),ie=JSON.parse('{"title":"Calculator","description":"","frontmatter":{},"headers":[],"relativePath":"+calculator.md","filePath":"+calculator.md"}'),ce={name:"+calculator.md"},de=Object.assign(ce,{setup(O){return(a,f)=>(_(),p("div",null,[le,ue,A(re)]))}});export{ie as __pageData,de as default};
