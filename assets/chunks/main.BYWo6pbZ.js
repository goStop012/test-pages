var j=Object.defineProperty;var q=i=>{throw TypeError(i)};var Y=(i,t,e)=>t in i?j(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var r=(i,t,e)=>Y(i,typeof t!="symbol"?t+"":t,e),D=(i,t,e)=>t.has(i)||q("Cannot "+e);var o=(i,t,e)=>(D(i,t,"read from private field"),e?e.call(i):t.get(i)),a=(i,t,e)=>t.has(i)?q("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(i):t.set(i,e),f=(i,t,e,s)=>(D(i,t,"write to private field"),s?s.call(i,e):t.set(i,e),e),T=(i,t,e)=>(D(i,t,"access private method"),e);class Utils{static isType(t,e){return Object.prototype.toString.call(t)===`[object ${e}]`}static isNumber(t){return this.isType(t,"Number")&&!Number.isNaN(t)}static isString(t){return this.isType(t,"String")}static isBoolean(t){return this.isType(t,"Boolean")}static isArray(t){return this.isType(t,"Array")}static isObject(t){return this.isType(t,"Object")}static isRegExp(t){return this.isType(t,"RegExp")}static isUndefined(t){return this.isType(t,"Undefined")}static isNull(t){return this.isType(t,"Null")}static degreesToRadians(t){return t*Math.PI/180}static radiansToDegrees(t){return(t*(180/Math.PI)+360)%360}static parseBinary(t){return parseInt(t,2)}static toBinaryString(t){return t.toString(2)}static formatNumber(t){return typeof t=="number"?parseFloat(t.toFixed(4)):t}static formatStringOrBoolean(t){return typeof t=="string"||typeof t=="boolean"?t.toString().toUpperCase():t}static objectFormat(t){const e={};for(let s in t){const n=t[s];this.isObject(n)?e[s]=this.objectFormat(n):(this.isNumber(n)&&(e[s]=Utils.formatNumber(n)),(this.isString(n)||this.isBoolean(n))&&(e[s]=Utils.formatStringOrBoolean(n)))}return e}static deepCopy(t){if(this.isNull(t)||!this.isObject(t))return t;let e=this.isArray(t)?[]:{};for(let s in t)e[s]=this.deepCopy(t[s]);return e}static intersection(...t){return t.reduce((e,s)=>e.filter(n=>s.includes(n)))}static union(...t){return[...new Set(t.reduce((e,s)=>e.concat(s),[]))]}static difference(...t){const[e,...s]=t;return e.filter(n=>!s.some(h=>h.includes(n)))}}class Point{constructor(t){r(this,"x");r(this,"y");if(this.isXZInput(t))this.x=t.z,this.y=t.x/2;else if(this.isXYInput(t))this.x=t.x,this.y=t.y;else throw new Error(`${this.constructor.name}，Point assignment error: Invalid object structure. Current object is: ${JSON.stringify(t)}`);this.x=Utils.formatNumber(this.x),this.y=Utils.formatNumber(this.y)}isXYInput(t){return"y"in t}isXZInput(t){return"z"in t}add(t){return new Point({x:this.x+t.x,y:this.y+t.y})}sub(t){return new Point({x:this.x-t.x,y:this.y-t.y})}div(t){if(t===0)throw new Error(`${this.constructor.name}，Division by zero`);return new Point({x:this.x/t,y:this.y/t})}mul(t){return new Point({x:this.x*t,y:this.y*t})}toLathePoint(){return{x:Utils.formatNumber(this.y*2),z:this.x}}toLatheAxisPrint(t=" "){const{x:e,z:s}=this.toLathePoint();return`X${e}${t}Z${s}`}print(t=" "){return`${this.x}${t}${this.y}`}toAxisPrint(t=" "){return`X${this.x}${t}Y${this.y}`}}var P,y,B,m,x,w,A,U;const C=class C{constructor(t,e){r(this,"startPoint");r(this,"endPoint");a(this,P);a(this,y);a(this,B);a(this,m);a(this,x);a(this,w);a(this,A);a(this,U);this.startPoint=t,this.endPoint=e}get vector(){return o(this,P)||f(this,P,this.endPoint.sub(this.startPoint)),o(this,P)}get distance(){return o(this,y)||f(this,y,Marco.sqrt(this.vector.x**2+this.vector.y**2)),o(this,y)}get unitVector(){return o(this,B)||f(this,B,this.vector.div(this.distance)),o(this,B)}get middle(){return o(this,m)||f(this,m,this.startPoint.add(this.endPoint).div(2)),o(this,m)}get slope(){return o(this,x)||f(this,x,this.vector.x===0?1/0:this.vector.y/this.vector.x),o(this,x)}get angle(){return o(this,w)||f(this,w,Utils.radiansToDegrees(Math.atan2(this.vector.y,this.vector.x))),o(this,w)}get increase(){return o(this,A)||f(this,A,new Point({y:(this.endPoint.y-this.startPoint.y)/2,x:this.endPoint.x-this.startPoint.x})),o(this,A)}get direction(){if(!o(this,U)){if(this.angle===90)return"↑";if(this.angle===270)return"↓";if(this.angle===0)return"→";if(this.angle===180)return"←";if(this.increase.x>0&&this.increase.y<0)return"↘";if(this.increase.x<0&&this.increase.y<0)return"↙";if(this.increase.x>0&&this.increase.y>0)return"↗";if(this.increase.x<0&&this.increase.y>0)return"↖"}return o(this,U)}extendOrShorten(t={}){const{length:s=1,relative:n="startPoint",vertical:h=!0}=t,d=s/1,l=n==="startPoint"?-1:1;let u;h?u=new RightTriangleOfSideLength({angle:this.angle%90,sideLengthA:1}).toPoint():u=new RightTriangleOfSideLength({angle:this.angle%90,sideLengthC:1}).toPoint();const g=this[n].y+u.y*Math.sign(this.vector.y)*d*l,c=this[n].x+u.x*Math.sign(this.vector.x)*d*l;return n==="startPoint"?new C(new Point({y:g,x:c}),this.endPoint):new C(this.startPoint,new Point({y:g,x:c}))}rotateByStart(t){const e=Utils.degreesToRadians(t),s=Math.cos(e),n=Math.sin(e),h=this.vector.x*s-this.vector.y*n,d=this.vector.x*n+this.vector.y*s;return new C(this.startPoint,new Point({x:h,y:d}).add(this.startPoint))}translation(t){return new C(this.startPoint.add(t),this.endPoint.add(t))}};P=new WeakMap,y=new WeakMap,B=new WeakMap,m=new WeakMap,x=new WeakMap,w=new WeakMap,A=new WeakMap,U=new WeakMap;let Line=C;var p,R,S,O,F;class Tolerance{constructor(i={}){a(this,O);r(this,"tolerance");a(this,p);a(this,R);a(this,S);r(this,"maximum");r(this,"nominal");r(this,"minimum");const{tolerance:t="62 0.05 -0.05"}=i;this.tolerance=t,T(this,O,F).call(this)}}p=new WeakMap,R=new WeakMap,S=new WeakMap,O=new WeakSet,F=function(){const value=this.tolerance.split(" ").filter(i=>i);f(this,p,eval(value.at(0))||0),f(this,R,parseFloat(value.at(1))||0),f(this,S,parseFloat(value.at(2))||0),this.maximum=o(this,p)+o(this,R),this.nominal=o(this,p)+(o(this,R)+o(this,S))/2,this.minimum=o(this,p)+o(this,S)};var N,X;class ChamferSimple{constructor(t={}){a(this,N);r(this,"toolRadius");r(this,"value");r(this,"type");r(this,"u");r(this,"w");const{toolRadius:e=.4,value:s=1,type:n="chamfer"}=t;this.toolRadius=e,this.value=s,this.type=n,T(this,N,X).call(this)}}N=new WeakSet,X=function(){this.type==="chamfer"?(this.w=this.value+RightTriangleOfSideLengthCRC.getCrcLength(this.toolRadius,45),this.u=this.w*2):this.type==="radius"&&(this.w=this.value+this.toolRadius,this.u=this.w*2)};var $,G;class RightTriangleOfSideLength{constructor(t={}){a(this,$);r(this,"sideLengthA");r(this,"sideLengthB");r(this,"sideLengthC");r(this,"angle");const{angle:e=0,sideLengthA:s=0,sideLengthB:n=0,sideLengthC:h=0}=t;if(this.angle=e,console.log(e,"=>",e%90),this.sideLengthA=s,this.sideLengthB=n,this.sideLengthC=h,!this.valid())throw new Error(`${this.constructor.name}，Invalid parameters: ${JSON.stringify({angle:e,sideLengthA:s,sideLengthB:n,sideLengthC:h})}`);T(this,$,G).call(this)}valid(){const t=s=>Utils.isNumber(s)&&s>0;return[this.angle,this.sideLengthA,this.sideLengthB,this.sideLengthC].filter(s=>t(s)).length===2}getSideLengthA(){return Marco.sqrt(this.sideLengthC**2-this.sideLengthB**2)}getSideLengthB(){return Marco.sqrt(this.sideLengthC**2-this.sideLengthA**2)}getSideLengthC(){return Marco.sqrt(this.sideLengthA**2+this.sideLengthB**2)}toPoint(){return new Point({x:this.sideLengthA*2,z:this.sideLengthB})}}$=new WeakSet,G=function(){this.angle?this.sideLengthA?(this.sideLengthB=this.sideLengthA*Marco.tan(this.angle),this.sideLengthC=this.getSideLengthC()):this.sideLengthB?(this.sideLengthA=this.sideLengthB/Marco.tan(this.angle),this.sideLengthC=this.getSideLengthC()):this.sideLengthC&&(this.sideLengthA=this.sideLengthC*Marco.cos(this.angle),this.sideLengthB=this.getSideLengthB()):(this.sideLengthA&&this.sideLengthB?this.sideLengthC=this.getSideLengthC():this.sideLengthA&&this.sideLengthC?this.sideLengthB=this.getSideLengthB():this.sideLengthB&&this.sideLengthC&&(this.sideLengthA=this.getSideLengthA()),this.angle=Marco.acos(this.sideLengthA/this.sideLengthC))};var E,V;const I=class I extends RightTriangleOfSideLength{constructor(e={}){super(e);a(this,E);r(this,"sideLengthACRC");r(this,"sideLengthBCRC");r(this,"toolRadius");const{toolRadius:s=0,angle:n,sideLengthA:h,sideLengthB:d,sideLengthC:l}=e;if(s<0)throw new Error(`${this.constructor.name}，当前值：toolRadius = ${s}，取值范围：toolRadius > 0`);this.toolRadius=s,T(this,E,V).call(this)}static getCrcLength(e,s){return e*(1-Marco.tan(s/2))}toPoint(){return new Point({x:this.sideLengthACRC*2,z:this.sideLengthBCRC})}};E=new WeakSet,V=function(){if(!this.angle)throw new Error(`${this.constructor.name}，Triangle angle must be set before calculating CRC.`);this.sideLengthACRC=I.getCrcLength(this.toolRadius,this.angle),this.sideLengthBCRC=I.getCrcLength(this.toolRadius,90-this.angle)};let RightTriangleOfSideLengthCRC=I;class ChamferBase{constructor({quadrant:t="第一象限",pointC:e=new Point({x:100,z:0}),angle:s=45,value:n=1,direction:h="逆时针",position:d="外侧",toolRadius:l=.4}={}){r(this,"quadrant");r(this,"pointC");r(this,"angle");r(this,"value");r(this,"direction");r(this,"position");r(this,"toolRadius");r(this,"pointA");r(this,"pointB");this.quadrant=t,this.pointC=e,this.angle=s,this.value=n,this.direction=h,this.position=d,this.toolRadius=l}}class RtypeChamfer extends ChamferBase{constructor(e={}){const{quadrant:s="第一象限",pointC:n=new Point({x:100,z:0}),angle:h=45,value:d=1,direction:l="逆时针",position:u="外侧",toolRadius:g=.4}=e;super(e);r(this,"radius");r(this,"radiusCRC");this.radius=h===45?this.value:void 0;const c=this.calc();this.pointA=c.pointA,this.pointB=c.pointB,this.radiusCRC=c.radiusCRC}calc(){const e=new RightTriangleOfSideLength({angle:this.angle,sideLengthA:this.value}),s={第一象限:{pointA:new Point({x:-(e.sideLengthA*2),z:0}),pointB:new Point({x:0,z:-e.sideLengthB})},第四象限:{pointA:new Point({x:0,z:-e.sideLengthB}),pointB:new Point({x:e.sideLengthA*2,z:0})},第二象限:{pointA:new Point({x:0,z:e.sideLengthB}),pointB:new Point({x:-(e.sideLengthA*2),z:0})},第三象限:{pointA:new Point({x:e.sideLengthA*2,z:0}),pointB:new Point({x:0,z:e.sideLengthB})}},n=this.toolRadius!==0,h=this.position==="外侧",d=this.direction==="顺时针",l=n?this.toolRadius:0,u=h?1:-1,g=s[this.quadrant],c=g.pointA.mul(l*u),b=g.pointB.mul(l*u),M=new Point(this.pointC).add(g.pointA).add(c),z=new Point(this.pointC).add(g.pointB).add(b),L=this.radius??0,v=n?h?L+this.toolRadius:L-this.toolRadius:L;return d?{pointA:z,pointB:M,radiusCRC:v}:{pointA:M,pointB:z,radiusCRC:v}}}class CtypeChamfer extends ChamferBase{constructor(e={}){const{quadrant:s="第一象限",pointC:n=new Point({x:100,z:0}),angle:h=45,value:d=1,direction:l="逆时针",position:u="外侧",toolRadius:g=0}=e;super(e);r(this,"chamfer");r(this,"chamferCRC");r(this,"unitVector");r(this,"length");r(this,"arrowDirection");r(this,"extendFromPointA");this.chamfer=this.angle===45?this.value:void 0;const c=this.calc();this.pointA=c.pointA,this.pointB=c.pointB,this.chamferCRC=c.chamferCRC,this.arrowDirection=new Line(this.pointA,this.pointB).direction,this.unitVector=new Line(this.pointA,this.pointB).unitVector,this.extendFromPointA=new Line(this.pointA,this.pointB).extendOrShorten().startPoint,this.length=new Line(this.pointA,this.pointB).distance}calc(){const e=new RightTriangleOfSideLengthCRC({toolRadius:this.toolRadius,angle:this.angle,sideLengthA:this.value}),s={第一象限:{pointA:new Point({x:-(e.sideLengthA*2),z:0}),pointB:new Point({x:0,z:-e.sideLengthB})},第四象限:{pointA:new Point({x:0,z:-e.sideLengthB}),pointB:new Point({x:e.sideLengthA*2,z:0})},第二象限:{pointA:new Point({x:0,z:e.sideLengthB}),pointB:new Point({x:-(e.sideLengthA*2),z:0})},第三象限:{pointA:new Point({x:e.sideLengthA*2,z:0}),pointB:new Point({x:0,z:e.sideLengthB})}},n=this.toolRadius!==0,h=this.position==="外侧",d=this.direction==="顺时针",l=n?1:0,u={sideLengthACRC:e.sideLengthACRC*l,sideLengthBCRC:e.sideLengthBCRC*l},g=h?1:-1,{pointA:c,pointB:b}=s[this.quadrant],M=c.mul(u.sideLengthACRC*g),z=b.mul(u.sideLengthBCRC*g),L=new Point(this.pointC).add(c).add(M),v=new Point(this.pointC).add(b).add(z);return this.chamferCRC=this.chamfer?this.chamfer+RightTriangleOfSideLengthCRC.getCrcLength(this.toolRadius,45)*g:null,d?{pointA:v,pointB:L,chamferCRC:this.chamferCRC}:{pointA:L,pointB:v,chamferCRC:this.chamferCRC}}}class G94{constructor(t={}){r(this,"startPoint");r(this,"endPoint");r(this,"taper");r(this,"direction");r(this,"angle");const{startPoint:e=new Point({x:100,z:0}),endPoint:s=new Point({x:120,z:-10})}=t;this.startPoint=e,this.endPoint=s;const n=new Line(new Point(e),new Point(s));this.taper=n.vector.toLathePoint().z,this.angle=n.angle,this.direction=n.direction}}class G90{constructor(t={}){r(this,"startPoint");r(this,"endPoint");r(this,"taper");r(this,"direction");r(this,"angle");const{startPoint:e=new Point({x:100,z:0}),endPoint:s=new Point({x:120,z:-10})}=t;this.startPoint=e,this.endPoint=s;const n=new Line(new Point(e),new Point(s));this.taper=n.vector.div(2).toLathePoint().x,this.angle=n.angle,this.direction=n.direction}}const Marco_={"+":(i,t)=>i+t,"-":(i,t)=>i-t,"*":(i,t)=>i*t,"/":(i,t)=>i/t,EQ:(i,t)=>i===t,NE:(i,t)=>i!==t,GT:(i,t)=>i>t,GE:(i,t)=>i>=t,LT:(i,t)=>i<t,LE:(i,t)=>i<=t,AND:(i,t)=>Utils.toBinaryString(Utils.parseBinary(i)&Utils.parseBinary(t)),OR:(i,t)=>Utils.toBinaryString(Utils.parseBinary(i)|Utils.parseBinary(t)),XOR:(i,t)=>Utils.toBinaryString(Utils.parseBinary(i)^Utils.parseBinary(t)),NOT:i=>Utils.toBinaryString(~Utils.parseBinary(i)),SIN:i=>Math.sin(Utils.degreesToRadians(i)),COS:i=>Math.cos(Utils.degreesToRadians(i)),TAN:i=>Math.tan(Utils.degreesToRadians(i)),ASIN:i=>Utils.radiansToDegrees(Math.asin(i)),ACOS:i=>Utils.radiansToDegrees(Math.acos(i)),ATAN:i=>Utils.radiansToDegrees(Math.atan(i)),SQRT:i=>Math.sqrt(i),ABS:i=>Math.abs(i),ROUND:i=>Math.round(i),EXP:i=>Math.exp(i),LN:i=>Math.log(i),FIX:i=>Math.floor(i),FUP:i=>Math.ceil(i),B2D:i=>Utils.parseBinary(i).toString(),D2B:i=>Utils.toBinaryString(i*1)},handler={get(i,t){const e=t.toUpperCase();return(...s)=>{if(!(e in i))throw new Error(`${this.constructor.name}，Operation ${e} is not defined.`);const n=i[e](...s);return typeof n=="number"?Utils.formatNumber(n):typeof n=="string"||typeof n=="boolean"?Utils.formatStringOrBoolean(n):n}}},Marco=new Proxy(Marco_,handler);export{ChamferSimple as C,G90 as G,Marco as M,Point as P,RtypeChamfer as R,Tolerance as T,Utils as U,CtypeChamfer as a,G94 as b};
