class s{static isType(t,r){return Object.prototype.toString.call(t)===`[object ${r}]`}static isNumber(t){return this.isType(t,"Number")&&!Number.isNaN(t)}static isString(t){return this.isType(t,"String")}static isBoolean(t){return this.isType(t,"Boolean")}static isArray(t){return this.isType(t,"Array")}static isObject(t){return this.isType(t,"Object")}static isRegExp(t){return this.isType(t,"RegExp")}static isUndefined(t){return this.isType(t,"Undefined")}static isNull(t){return this.isType(t,"Null")}static degreesToRadians(t){return t*Math.PI/180}static radiansToDegrees(t){return(t*(180/Math.PI)+360)%360}static parseBinary(t){return parseInt(t,2)}static toBinaryString(t){return t.toString(2)}static formatNumber(t,r){return typeof t=="number"&&r?parseFloat(t.toFixed(r)):t}static formatStringOrBoolean(t){return typeof t=="string"||typeof t=="boolean"?t.toString().toUpperCase():t}static objectFormat(t){const r={};for(let i in t){const e=t[i];this.isObject(e)?r[i]=this.objectFormat(e):(this.isNumber(e)&&(r[i]=s.formatNumber(e,5)),(this.isString(e)||this.isBoolean(e))&&(r[i]=s.formatStringOrBoolean(e)))}return r}static deepCopy(t,r=new WeakMap){if(t===null||typeof t!="object")return t;if(r.has(t))return r.get(t);if(Array.isArray(t)){const i=[];r.set(t,i);for(let e=0;e<t.length;e++)i[e]=this.deepCopy(t[e],r);return i}if(this.isObject(t)||t instanceof Date||t instanceof RegExp){const i={};r.set(t,i);for(const e in t)t.hasOwnProperty(e)&&(i[e]=this.deepCopy(t[e],r));return i}throw new Error("Unable to copy object! Its type isn't supported.")}static intersection(...t){return t.reduce((r,i)=>r.filter(e=>i.includes(e)))}static union(...t){return[...new Set(t.flat())]}static difference(...t){const[r,...i]=t;return r.filter(e=>!i.some(n=>n.includes(e)))}}export{s as U};
