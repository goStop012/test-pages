var G=Object.defineProperty;var F=i=>{throw TypeError(i)};var J=(i,t,e)=>t in i?G(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var r=(i,t,e)=>J(i,typeof t!="symbol"?t+"":t,e),X=(i,t,e)=>t.has(i)||F("Cannot "+e);var n=(i,t,e)=>(X(i,t,"read from private field"),e?e.call(i):t.get(i)),a=(i,t,e)=>t.has(i)?F("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(i):t.set(i,e),l=(i,t,e,s)=>(X(i,t,"write to private field"),s?s.call(i,e):t.set(i,e),e),U=(i,t,e)=>(X(i,t,"access private method"),e);class Utils{static isType(t,e){return Object.prototype.toString.call(t)===`[object ${e}]`}static isNumber(t){return this.isType(t,"Number")&&!Number.isNaN(t)}static isString(t){return this.isType(t,"String")}static isBoolean(t){return this.isType(t,"Boolean")}static isArray(t){return this.isType(t,"Array")}static isObject(t){return this.isType(t,"Object")}static isRegExp(t){return this.isType(t,"RegExp")}static isUndefined(t){return this.isType(t,"Undefined")}static isNull(t){return this.isType(t,"Null")}static degreesToRadians(t){return t*Math.PI/180}static radiansToDegrees(t){return(t*(180/Math.PI)+360)%360}static parseBinary(t){return parseInt(t,2)}static toBinaryString(t){return t.toString(2)}static formatNumber(t){return typeof t=="number"?parseFloat(t.toFixed(4)):t}static formatStringOrBoolean(t){return typeof t=="string"||typeof t=="boolean"?t.toString().toUpperCase():t}static objectFormat(t){const e={};for(let s in t){const h=t[s];this.isObject(h)?e[s]=this.objectFormat(h):(this.isNumber(h)&&(e[s]=Utils.formatNumber(h)),(this.isString(h)||this.isBoolean(h))&&(e[s]=Utils.formatStringOrBoolean(h)))}return e}static deepCopy(t){if(this.isNull(t)||!this.isObject(t))return t;let e=this.isArray(t)?[]:{};for(let s in t)e[s]=this.deepCopy(t[s]);return e}static intersection(...t){return t.reduce((e,s)=>e.filter(h=>s.includes(h)))}static union(...t){return[...new Set(t.reduce((e,s)=>e.concat(s),[]))]}static difference(...t){const[e,...s]=t;return e.filter(h=>!s.some(o=>o.includes(h)))}}class Point{constructor(t){r(this,"x");r(this,"y");if(this.isXZInput(t))this.x=t.z,this.y=t.x/2;else if(this.isXYInput(t))this.x=t.x,this.y=t.y;else throw new Error(`${this.constructor.name}，Point assignment error: Invalid object structure. Current object is: ${JSON.stringify(t)}`);this.x=Utils.formatNumber(this.x),this.y=Utils.formatNumber(this.y)}isXYInput(t){return"y"in t}isXZInput(t){return"z"in t}add(t){return new Point({x:this.x+t.x,y:this.y+t.y})}sub(t){return new Point({x:this.x-t.x,y:this.y-t.y})}div(t){if(t===0)throw new Error(`${this.constructor.name}，Division by zero`);return new Point({x:this.x/t,y:this.y/t})}mul(t){return new Point({x:this.x*t,y:this.y*t})}toLathePoint(){return{x:Utils.formatNumber(this.y*2),z:this.x}}toLatheAxisPrint(t=" "){const{x:e,z:s}=this.toLathePoint();return`X${e}${t}Z${s}`}print(t=" "){return`${this.x}${t}${this.y}`}toAxisPrint(t=" "){return`X${this.x}${t}Y${this.y}`}}var B,m,A,R,x,w,S,b;const z=class z{constructor(t,e){r(this,"start");r(this,"end");a(this,B);a(this,m);a(this,A);a(this,R);a(this,x);a(this,w);a(this,S);a(this,b);this.start=t,this.end=e}get vector(){return n(this,B)||l(this,B,this.end.sub(this.start)),n(this,B)}get distance(){return n(this,m)||l(this,m,Math.sqrt(this.vector.x**2+this.vector.y**2)),n(this,m)}get unitVector(){return n(this,A)||l(this,A,this.vector.div(this.distance)),n(this,A)}get middle(){return n(this,R)||l(this,R,this.start.add(this.end).div(2)),n(this,R)}get slope(){return n(this,x)||l(this,x,this.vector.x===0?1/0:this.vector.y/this.vector.x),n(this,x)}get angle(){return n(this,w)||l(this,w,Utils.radiansToDegrees(Math.atan2(this.vector.y,this.vector.x))),n(this,w)}get increase(){return n(this,S)||l(this,S,new Point({y:(this.end.y-this.start.y)/2,x:this.end.x-this.start.x})),n(this,S)}get direction(){if(!n(this,b)){if(this.angle===90)return"↑";if(this.angle===270)return"↓";if(this.angle===0)return"→";if(this.angle===180)return"←";if(this.increase.x>0&&this.increase.y<0)return"↘";if(this.increase.x<0&&this.increase.y<0)return"↙";if(this.increase.x>0&&this.increase.y>0)return"↗";if(this.increase.x<0&&this.increase.y>0)return"↖"}return n(this,b)}extend(t={length:1,relative:"start",vertical:!1}){const{length:e,relative:s,vertical:h}=t;let o=e/1,c;const d=this.vector.y*-1;c=this.unitVector.mul(o).mul(d);const p=new z(this.start.add(c),this.end);return{newLine:p,angle:p.angle,vector:p.vector}}rotateByStart(t){const e=Utils.degreesToRadians(t),s=Math.cos(e),h=Math.sin(e),o=this.vector.x*s-this.vector.y*h,c=this.vector.x*h+this.vector.y*s;return new z(this.start,new Point({x:o,y:c}).add(this.start))}};B=new WeakMap,m=new WeakMap,A=new WeakMap,R=new WeakMap,x=new WeakMap,w=new WeakMap,S=new WeakMap,b=new WeakMap;let Line=z;var L,v,P,$,V;class Tolerance{constructor(i={}){a(this,$);r(this,"tolerance");a(this,L);a(this,v);a(this,P);r(this,"maximum");r(this,"nominal");r(this,"minimum");const{tolerance:t="62 0.05 -0.05"}=i;this.tolerance=t,U(this,$,V).call(this)}}L=new WeakMap,v=new WeakMap,P=new WeakMap,$=new WeakSet,V=function(){const value=this.tolerance.split(" ").filter(i=>i);l(this,L,eval(value.at(0))||0),l(this,v,parseFloat(value.at(1))||0),l(this,P,parseFloat(value.at(2))||0),this.maximum=n(this,L)+n(this,v),this.nominal=n(this,L)+(n(this,v)+n(this,P))/2,this.minimum=n(this,L)+n(this,P)};var E,j;class ChamferSimple{constructor(t={}){a(this,E);r(this,"toolRadius");r(this,"value");r(this,"type");r(this,"u");r(this,"w");const{toolRadius:e=.4,value:s=1,type:h="chamfer"}=t;this.toolRadius=e,this.value=s,this.type=h,U(this,E,j).call(this)}}E=new WeakSet,j=function(){this.type==="chamfer"?(this.w=this.value+RightTriangleOfSideLengthCRC.getCrcLength(this.toolRadius,45),this.u=this.w*2):this.type==="radius"&&(this.w=this.value+this.toolRadius,this.u=this.w*2)};var I,Y;class RightTriangleOfSideLength{constructor(t={}){a(this,I);r(this,"sideLengthA");r(this,"sideLengthB");r(this,"sideLengthC");r(this,"angle");r(this,"sideLengthACRC");r(this,"sideLengthBCRC");r(this,"toolRadius");const{angle:e=0,sideLengthA:s=0,sideLengthB:h=0,sideLengthC:o=0}=t;if(this.angle=e,this.sideLengthA=s,this.sideLengthB=h,this.sideLengthC=o,!this.valid())throw new Error(`${this.constructor.name}，Invalid parameters: ${JSON.stringify({angle:e,sideLengthA:s,sideLengthB:h,sideLengthC:o})}`);U(this,I,Y).call(this)}valid(){const t=s=>Utils.isNumber(s)&&s>0;return[this.angle,this.sideLengthA,this.sideLengthB,this.sideLengthC].filter(s=>t(s)).length===2}getSideLengthA(){return Marco.sqrt(this.sideLengthC**2-this.sideLengthB**2)}getSideLengthB(){return Marco.sqrt(this.sideLengthC**2-this.sideLengthA**2)}getSideLengthC(){return Marco.sqrt(this.sideLengthA**2+this.sideLengthB**2)}}I=new WeakSet,Y=function(){this.angle?this.sideLengthA?(this.sideLengthB=this.sideLengthA*Marco.tan(this.angle),this.sideLengthC=this.getSideLengthC()):this.sideLengthB?(this.sideLengthA=this.sideLengthB/Marco.tan(this.angle),this.sideLengthC=this.getSideLengthC()):this.sideLengthC&&(this.sideLengthA=this.sideLengthC*Marco.cos(this.angle),this.sideLengthB=this.getSideLengthB()):(this.sideLengthA&&this.sideLengthB?this.sideLengthC=this.getSideLengthC():this.sideLengthA&&this.sideLengthC?this.sideLengthB=this.getSideLengthB():this.sideLengthB&&this.sideLengthC&&(this.sideLengthA=this.getSideLengthA()),this.angle=Marco.acos(this.sideLengthA/this.sideLengthC))};var D,Z;const q=class q extends RightTriangleOfSideLength{constructor(e={}){super(e);a(this,D);const{toolRadius:s=0,angle:h,sideLengthA:o,sideLengthB:c,sideLengthC:d}=e;if(s<0)throw new Error(`${this.constructor.name}，当前值：toolRadius = ${s}，取值范围：toolRadius > 0`);this.toolRadius=s,U(this,D,Z).call(this)}static getCrcLength(e,s){return e*(1-Marco.tan(s/2))}};D=new WeakSet,Z=function(){if(!this.angle)throw new Error(`${this.constructor.name}，Triangle angle must be set before calculating CRC.`);this.sideLengthACRC=q.getCrcLength(this.toolRadius,this.angle),this.sideLengthBCRC=q.getCrcLength(this.toolRadius,90-this.angle)};let RightTriangleOfSideLengthCRC=q;class ChamferBase{constructor({quadrant:t="第一象限",pointC:e=new Point({x:100,z:0}),angle:s=45,value:h=1,direction:o="逆时针",position:c="外侧",toolRadius:d=.4}={}){r(this,"quadrant");r(this,"pointC");r(this,"angle");r(this,"value");r(this,"direction");r(this,"position");r(this,"toolRadius");r(this,"pointA");r(this,"pointB");this.quadrant=t,this.pointC=e,this.angle=s,this.value=h,this.direction=o,this.position=c,this.toolRadius=d}}var M,f;class RtypeChamfer extends ChamferBase{constructor(e={}){const{quadrant:s="第一象限",pointC:h=new Point({x:100,z:0}),angle:o=45,value:c=1,direction:d="逆时针",position:p="外侧",toolRadius:C=.4}=e;super(e);a(this,M);r(this,"radius");r(this,"radiusCRC");a(this,f);this.radius=o===45?this.value:void 0,l(this,f,new RightTriangleOfSideLength({angle:o,sideLengthA:c})),l(this,M,{第一象限:{pointA:new Point({x:-(n(this,f).sideLengthA*2),z:0}),pointB:new Point({x:0,z:-n(this,f).sideLengthB})},第四象限:{pointA:new Point({x:0,z:-n(this,f).sideLengthB}),pointB:new Point({x:n(this,f).sideLengthA*2,z:0})},第二象限:{pointA:new Point({x:0,z:n(this,f).sideLengthB}),pointB:new Point({x:-(n(this,f).sideLengthA*2),z:0})},第三象限:{pointA:new Point({x:n(this,f).sideLengthA*2,z:0}),pointB:new Point({x:0,z:n(this,f).sideLengthB})}});const u=this.calc();this.pointA=u.pointA,this.pointB=u.pointB,this.radiusCRC=u.radiusCRC}calc(){const e=this.toolRadius!==0,s=this.position==="外侧",h=this.direction==="顺时针",o=e?this.toolRadius:0,c=s?1:-1,d=n(this,M)[this.quadrant],p=d.pointA.mul(o*c),C=d.pointB.mul(o*c),u=new Point(this.pointC).add(d.pointA).add(p),O=new Point(this.pointC).add(d.pointB).add(C),y=this.radius??0,T=e?s?y+this.toolRadius:y-this.toolRadius:y;return h?{pointA:O,pointB:u,radiusCRC:T}:{pointA:u,pointB:O,radiusCRC:T}}}M=new WeakMap,f=new WeakMap;var N,g;class CtypeChamfer extends ChamferBase{constructor(e={}){const{quadrant:s="第一象限",pointC:h=new Point({x:100,z:0}),angle:o=45,value:c=1,direction:d="逆时针",position:p="外侧",toolRadius:C=.4}=e;super(e);a(this,N);r(this,"chamfer");r(this,"chamferCRC");r(this,"unitVector");r(this,"length");r(this,"arrowDirection");a(this,g);this.chamfer=this.angle===45?this.value:null,l(this,g,new RightTriangleOfSideLengthCRC({toolRadius:C,angle:o,sideLengthA:c})),l(this,N,{第一象限:{pointA:new Point({x:-(n(this,g).sideLengthA*2),z:0}),pointB:new Point({x:0,z:-n(this,g).sideLengthB})},第四象限:{pointA:new Point({x:0,z:-n(this,g).sideLengthB}),pointB:new Point({x:n(this,g).sideLengthA*2,z:0})},第二象限:{pointA:new Point({x:0,z:n(this,g).sideLengthB}),pointB:new Point({x:-(n(this,g).sideLengthA*2),z:0})},第三象限:{pointA:new Point({x:n(this,g).sideLengthA*2,z:0}),pointB:new Point({x:0,z:n(this,g).sideLengthB})}});const u=this.calc();this.pointA=u.pointA,this.pointB=u.pointB,this.chamferCRC=u.chamferCRC,this.arrowDirection=new Line(this.pointA,this.pointB).direction,this.unitVector=new Line(this.pointA,this.pointB).unitVector,this.length=new Line(this.pointA,this.pointB).distance}calc(){const e=this.toolRadius!==0,s=this.position==="外侧",h=this.direction==="顺时针",o=e?1:0,c={sideLengthACRC:n(this,g).sideLengthACRC*o,sideLengthBCRC:n(this,g).sideLengthBCRC*o},d=s?1:-1,{pointA:p,pointB:C}=n(this,N)[this.quadrant],u=p.mul(c.sideLengthACRC*d),O=C.mul(c.sideLengthBCRC*d),y=new Point(this.pointC).add(p).add(u),T=new Point(this.pointC).add(C).add(O);return this.chamferCRC=(this.chamfer||void 0)+RightTriangleOfSideLengthCRC.getCrcLength(this.toolRadius,45)*d,h?{pointA:T,pointB:y,chamferCRC:this.chamferCRC}:{pointA:y,pointB:T,chamferCRC:this.chamferCRC}}}N=new WeakMap,g=new WeakMap;const Marco_={"+":(i,t)=>i+t,"-":(i,t)=>i-t,"*":(i,t)=>i*t,"/":(i,t)=>i/t,EQ:(i,t)=>i===t,NE:(i,t)=>i!==t,GT:(i,t)=>i>t,GE:(i,t)=>i>=t,LT:(i,t)=>i<t,LE:(i,t)=>i<=t,AND:(i,t)=>Utils.toBinaryString(Utils.parseBinary(i)&Utils.parseBinary(t)),OR:(i,t)=>Utils.toBinaryString(Utils.parseBinary(i)|Utils.parseBinary(t)),XOR:(i,t)=>Utils.toBinaryString(Utils.parseBinary(i)^Utils.parseBinary(t)),NOT:i=>Utils.toBinaryString(~Utils.parseBinary(i)),SIN:i=>Math.sin(Utils.degreesToRadians(i)),COS:i=>Math.cos(Utils.degreesToRadians(i)),TAN:i=>Math.tan(Utils.degreesToRadians(i)),ASIN:i=>Utils.radiansToDegrees(Math.asin(i)),ACOS:i=>Utils.radiansToDegrees(Math.acos(i)),ATAN:i=>Utils.radiansToDegrees(Math.atan(i)),SQRT:i=>Math.sqrt(i),ABS:i=>Math.abs(i),ROUND:i=>Math.round(i),EXP:i=>Math.exp(i),LN:i=>Math.log(i),FIX:i=>Math.floor(i),FUP:i=>Math.ceil(i),B2D:i=>Utils.parseBinary(i).toString(),D2B:i=>Utils.toBinaryString(i*1)},handler={get(i,t){const e=t.toUpperCase();return(...s)=>{if(!(e in i))throw new Error(`${this.constructor.name}，Operation ${e} is not defined.`);const h=i[e](...s);return typeof h=="number"?Utils.formatNumber(h):typeof h=="string"||typeof h=="boolean"?Utils.formatStringOrBoolean(h):h}}},Marco=new Proxy(Marco_,handler);export{ChamferSimple as C,Marco as M,Point as P,RtypeChamfer as R,Tolerance as T,Utils as U,CtypeChamfer as a};
