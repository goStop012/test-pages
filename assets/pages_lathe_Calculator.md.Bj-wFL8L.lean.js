var $=Object.defineProperty;var E=d=>{throw TypeError(d)};var W=(d,s,t)=>s in d?$(d,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[s]=t;var e=(d,s,t)=>W(d,typeof s!="symbol"?s+"":s,t),H=(d,s,t)=>s.has(d)||E("Cannot "+t);var O=(d,s,t)=>s.has(d)?E("Cannot add the same private member more than once"):s instanceof WeakSet?s.add(d):s.set(d,t);var b=(d,s,t)=>(H(d,s,"access private method"),t);import{L as J,T as Q,a as K,b as P,c as X,d as q,e as N,f as Y,g as L,h as V,i as y,j as k,k as _,l as M,m as Z,n as tt,C as et}from"./chunks/inputValueType.CBxRsWn0.js";import{P as i}from"./chunks/Point.DhzxLGKq.js";import{U as D}from"./chunks/Utils.DC-NElVd.js";import{M as l}from"./chunks/Macro.4xAggGJu.js";import{d as it,o as U,c as G,C as st,F as nt,G as j,j as z,a as at}from"./chunks/framework.5q7voRLl.js";class m{constructor(s){e(this,"sideA");e(this,"sideB");e(this,"sideC");e(this,"angleA");e(this,"angleB");e(this,"angleC",90);const{sideA:t,sideB:a,sideC:n,angleA:o,angleB:h}=s;if(this.validateInput({sideA:t,sideB:a,sideC:n,angleA:o,angleB:h}),t&&a)this.sideA=t,this.sideB=a,this.sideC=l.sqrt(t**2+a**2),this.angleA=l.asin(a/this.sideC),this.angleB=90-this.angleA;else if(t&&n)this.sideA=t,this.sideC=n,this.sideB=l.sqrt(n**2-t**2),this.angleB=l.asin(t/n),this.angleA=90-this.angleB;else if(a&&n)this.sideB=a,this.sideC=n,this.sideA=l.sqrt(n**2-a**2),this.angleA=l.asin(a/n),this.angleB=90-this.angleA;else if(o&&t)this.angleA=o,this.sideA=t,this.angleB=90-o,this.sideC=t/l.cos(o),this.sideB=this.sideC*l.sin(o);else if(o&&a)this.angleA=o,this.sideB=a,this.angleB=90-o,this.sideC=a/l.sin(o),this.sideA=this.sideC*l.cos(o);else if(o&&n)this.angleA=o,this.sideC=n,this.angleB=90-o,this.sideB=n*l.sin(o),this.sideA=n*l.cos(o);else if(h&&t)this.angleB=h,this.sideA=t,this.angleA=90-h,this.sideC=t/l.sin(h),this.sideB=this.sideC*l.cos(h);else if(h&&a)this.angleB=h,this.sideB=a,this.angleA=90-h,this.sideC=a/l.cos(h),this.sideA=this.sideC*l.sin(h);else if(h&&n)this.angleB=h,this.sideC=n,this.angleA=90-h,this.sideA=n*l.sin(h),this.sideB=n*l.cos(h);else throw new Error("Invalid input combination.");this.validatePythagoras(),this.validateAngles()}validateInput(s){if(Object.values(s).filter(a=>a!==void 0).length<2)throw new Error("At least two values must be provided.")}validateAngles(){if(this.angleA&&this.angleB&&l.abs(this.angleA+this.angleB-90)>1e-4)throw new Error("The sum of angleA and angleB must be 90 degrees.")}validatePythagoras(){if(this.sideA&&this.sideB&&this.sideC&&l.abs(this.sideA**2+this.sideB**2-this.sideC**2)>1e-4)throw new Error("The lengths do not satisfy the Pythagorean theorem.")}toPoint(){if(this.sideA&&this.sideB)return new i({x:this.sideA*2,z:this.sideB})}}class R extends m{constructor(t={}){super(t);e(this,"toolRadius");e(this,"toolPositon");e(this,"sideACRC",0);e(this,"sideBCRC",0);const{toolRadius:a=0,toolPositon:n="前刀尖",angleA:o,sideA:h,sideB:r,sideC:c}=t;if(a<0)throw new Error(`${this.constructor.name}，当前值：toolRadius = ${a}，取值范围：toolRadius > 0`);if(!this.angleA)throw new Error(`${this.constructor.name}，Triangle angle must be set before calculating CRC.`);if(this.toolRadius=a,this.toolPositon=n,this.toolRadius===0)this.sideACRC=0,this.sideBCRC=0;else if(this.toolPositon==="前刀尖"&&(this.sideACRC=R.getSideCRC(this.toolRadius,this.angleA),this.sideBCRC=R.getSideCRC(this.toolRadius,90-this.angleA)),this.toolPositon==="后刀尖"){const u=R.getSideCRC(this.toolRadius,90-this.angleA);this.sideBCRC=this.toolRadius*2-u,this.sideACRC=new m({angleA:this.angleA,sideB:this.sideBCRC}).sideA}}static getSideCRC(t,a){return t-t*l.tan(a/2)}toPoint(){return new i({x:this.sideACRC*2,z:this.sideBCRC})}}class w{constructor(s,t){e(this,"startPoint");e(this,"endPoint");this.startPoint=s,this.endPoint=t}get vector(){return this.endPoint.sub(this.startPoint)}get distance(){return l.sqrt(this.vector.x**2+this.vector.y**2)}get unitVector(){return this.vector.div(this.distance)}get middle(){return this.startPoint.add(this.endPoint).div(2)}get slope(){return this.vector.x===0?1/0:this.vector.y/this.vector.x}get angle(){return D.radiansToDegrees(Math.atan2(this.vector.y,this.vector.x))}get increase(){return new i({y:(this.endPoint.y-this.startPoint.y)/2,x:this.endPoint.x-this.startPoint.x})}get direction(){return this.angle===90?"↑":this.angle===270?"↓":this.angle===0?"→":this.angle===180?"←":this.increase.x>0&&this.increase.y<0?"↘":this.increase.x<0&&this.increase.y<0?"↙":this.increase.x>0&&this.increase.y>0?"↗":this.increase.x<0&&this.increase.y>0?"↖":"null"}extendOrShorten(s={}){const{length:a=1,relative:n="startPoint",vertical:o=!0}=s,h=a/1,r=n==="startPoint"?-1:1;let c;o?c=new m({angleA:this.angle%90,sideA:1}).toPoint():c=new m({angleA:this.angle%90,sideC:1}).toPoint();const u=this[n].y+c.y*Math.sign(this.vector.y)*h*r,g=this[n].x+c.x*Math.sign(this.vector.x)*h*r;return n==="startPoint"?new w(new i({y:u,x:g}),this.endPoint):new w(this.startPoint,new i({y:u,x:g}))}rotateByStart(s){const t=D.degreesToRadians(s),a=Math.cos(t),n=Math.sin(t),o=this.vector.x*a-this.vector.y*n,h=this.vector.x*n+this.vector.y*a;return new w(this.startPoint,new i({x:o,y:h}).add(this.startPoint))}translation(s){return new w(this.startPoint.add(s),this.endPoint.add(s))}}var T,F;class ot{constructor(s={}){O(this,T);e(this,"toolRadius");e(this,"value");e(this,"type");e(this,"u");e(this,"w");const{toolRadius:t=.4,value:a=1,type:n="chamfer"}=s;this.toolRadius=t,this.value=a,this.type=n,b(this,T,F).call(this)}}T=new WeakSet,F=function(){this.type==="chamfer"?(this.w=this.value+R.getSideCRC(this.toolRadius,45),this.u=this.w*2):this.type==="radius"&&(this.w=this.value+this.toolRadius,this.u=this.w*2)};class I{constructor({quadrant:s="第一象限",pointC:t=new i({x:100,z:0}),angleA:a=45,value:n=1,direction:o="逆时针",position:h="外侧",toolRadius:r=.4,frontLineType:c="竖直",afterLineType:u="水平",toolPositon:g="前刀尖",valueType:x="Uhalf"}={}){e(this,"quadrant");e(this,"pointC");e(this,"angleA");e(this,"valueType");e(this,"value");e(this,"direction");e(this,"position");e(this,"toolRadius");e(this,"toolPositon");e(this,"frontLineType");e(this,"afterLineType");e(this,"pointA");e(this,"pointB");this.quadrant=s,this.pointC=t,this.angleA=a,this.value=n,this.direction=o,this.position=h,this.toolRadius=r,this.frontLineType=c,this.afterLineType=u,this.toolPositon=g,this.valueType=x}}class rt extends I{constructor(t={}){const{quadrant:a="第一象限",pointC:n=new i({x:100,z:0}),angleA:o=45,value:h=1,direction:r="逆时针",position:c="外侧",toolRadius:u=.4,frontLineType:g="竖直",afterLineType:x="水平"}=t;super(t);e(this,"radius");e(this,"radiusCRC");this.radius=o===45?this.value:void 0;const f=this.calc();this.pointA=f.pointA,this.pointB=f.pointB,this.radiusCRC=f.radiusCRC}calc(){const t=new m({angleA:this.angleA,sideA:this.value}),a={第一象限:{pointA:new i({x:-(t.sideA*2),z:0}),pointB:new i({x:0,z:-t.sideB})},第四象限:{pointA:new i({x:0,z:-t.sideB}),pointB:new i({x:t.sideA*2,z:0})},第二象限:{pointA:new i({x:0,z:t.sideB}),pointB:new i({x:-(t.sideA*2),z:0})},第三象限:{pointA:new i({x:t.sideA*2,z:0}),pointB:new i({x:0,z:t.sideB})}},n=this.toolRadius!==0,o=this.position==="外侧",h=this.direction==="顺时针",r=n?this.toolRadius:0,c=o?1:-1,u=a[this.quadrant],g=u.pointA.mul(r*c),x=u.pointB.mul(r*c),f=new i(this.pointC).add(u.pointA).add(g),v=new i(this.pointC).add(u.pointB).add(x),A=this.radius??0,p=n?o?A+this.toolRadius:A-this.toolRadius:A;return h?{pointA:v,pointB:f,radiusCRC:p}:{pointA:f,pointB:v,radiusCRC:p}}}class ht extends I{constructor(t={}){const{quadrant:a="第一象限",pointC:n=new i({x:100,z:0}),angleA:o=45,value:h=1,direction:r="逆时针",position:c="外侧",toolRadius:u=0}=t;super(t);e(this,"chamfer");e(this,"chamferCRC");e(this,"unitVector");e(this,"length");e(this,"arrowDirection");e(this,"extendFromPointA");this.chamfer=this.angleA===45?this.value:void 0;const g=this.calc();this.pointA=g.pointA,this.pointB=g.pointB,this.chamferCRC=g.chamferCRC,this.arrowDirection=new w(this.pointA,this.pointB).direction,this.unitVector=new w(this.pointA,this.pointB).unitVector,this.extendFromPointA=new w(this.pointA,this.pointB).extendOrShorten().startPoint,this.length=new w(this.pointA,this.pointB).distance}calc(){(this.quadrant==="第二象限"||this.quadrant==="第三象限")&&(this.toolPositon="后刀尖");let t;this.valueType==="Uhalf"&&(t=this.value),this.valueType==="W"&&(t=new m({angleA:this.angleA,sideB:this.value}).sideA);const a=new m({angleA:this.angleA,sideA:t}),n=new R({toolRadius:this.toolRadius,angleA:this.angleA,sideA:t,toolPositon:this.toolPositon}),o={第一象限:{pointA:new i({x:-2,z:0}),pointB:new i({x:0,z:-1})},第四象限:{pointA:new i({x:2,z:0}),pointB:new i({x:0,z:-1})},第二象限:{pointA:new i({x:-2,z:0}),pointB:new i({x:0,z:1})},第三象限:{pointA:new i({x:2,z:0}),pointB:new i({x:0,z:1})}},h={第一象限:{pointA:new i({x:-2,z:0}),pointB:new i({x:0,z:-1})},第四象限:{pointA:new i({x:2,z:0}),pointB:new i({x:0,z:-1})},第二象限:{pointA:new i({x:2,z:0}),pointB:new i({x:0,z:-1})},第三象限:{pointA:new i({x:2,z:0}),pointB:new i({x:0,z:1})}},r=this.toolRadius!==0,c=this.position==="外侧",u=this.direction==="顺时针",g=r?1:0,x=c?1:-1,f={A:o[this.quadrant].pointA,B:o[this.quadrant].pointB},v={A:h[this.quadrant].pointA,B:h[this.quadrant].pointB},A={B:f.B.mul(a.sideB),A:f.A.mul(a.sideA)},p={A:v.A.mul(n.sideACRC).mul(g).mul(x),B:v.B.mul(n.sideBCRC).mul(g).mul(x)};if(u){let S;S=A.A,A.A=A.B,A.B=S}let C=new i(this.pointC).add(A.A),B=new i(this.pointC).add(A.B);return this.frontLineType==="竖直"&&(this.afterLineType==="水平"&&(C=C.add(p.A),B=B.add(p.B)),this.afterLineType==="竖直"&&(C=C.add(p.A),B=B.add(p.A))),this.frontLineType==="水平"&&(this.afterLineType==="水平"&&(C=C.add(p.B),B=B.add(p.B)),this.afterLineType==="竖直"&&(C=C.add(p.B),B=B.add(p.A))),this.chamferCRC=this.chamfer?this.chamfer+R.getSideCRC(this.toolRadius,45)*x:null,{pointA:C,pointB:B,chamferCRC:this.chamferCRC}}}class dt{constructor(s={}){e(this,"startPoint");e(this,"endPoint");e(this,"startExtendLength");e(this,"endExtendLength");e(this,"toolRadius");e(this,"distance");e(this,"taper");e(this,"direction");e(this,"angle");e(this,"outStartPoint");e(this,"outEndPoint");const{startPoint:t=new i({x:100,z:0}),endPoint:a=new i({x:120,z:-10}),startExtendLength:n=0,endExtendLength:o=0,toolRadius:h=0}=s;this.startPoint=t,this.endPoint=a,this.startExtendLength=n,this.endExtendLength=o,this.toolRadius=h;let r=new w(new i(t),new i(a));r=r.extendOrShorten({length:n,relative:"startPoint"}),r=r.extendOrShorten({length:o,relative:"endPoint"}),this.taper=r.startPoint.x-r.endPoint.x,this.angle=r.angle,this.direction=r.direction,this.distance=r.distance,this.outStartPoint=r.startPoint,this.outEndPoint=r.endPoint}}class lt{constructor(s={}){e(this,"startPoint");e(this,"endPoint");e(this,"startExtendLength");e(this,"endExtendLength");e(this,"toolRadius");e(this,"taper");e(this,"direction");e(this,"distance");e(this,"angle");e(this,"outStartPoint");e(this,"outEndPoint");const{startPoint:t=new i({x:100,z:0}),endPoint:a=new i({x:120,z:-10}),startExtendLength:n=0,endExtendLength:o=0,toolRadius:h=0}=s;this.startPoint=t,this.endPoint=a,this.startExtendLength=n,this.endExtendLength=o,this.toolRadius=h;let r=new w(new i(t),new i(a));r=r.extendOrShorten({length:n,relative:"startPoint"}),r=r.extendOrShorten({length:o,relative:"endPoint"}),this.taper=r.startPoint.y-r.endPoint.y,this.angle=r.angle,this.direction=r.direction,this.distance=r.distance,this.outStartPoint=r.startPoint,this.outEndPoint=r.endPoint}}const ct=it({__name:"Calculator",setup(d){class s{constructor(n){e(this,"name");e(this,"keyOption");e(this,"input");e(this,"output");e(this,"className");const{name:o,keyOption:h={value:"",options:[]},input:r,className:c}=n;this.name=o,this.keyOption=h,this.input=r,this.className=c,this.output=new c(tt(r))}}const t=[new s({name:"Tolerance",input:{tolerance:new J},className:Q}),new s({name:"RightTriange-TowSide",keyOption:new K,input:{sideA:new P(3),sideB:new P(4)},className:m}),new s({name:"RightTriange-AngleAndSide",keyOption:new X,input:{angleA:new q(53.13),sideA:new P(3)},className:m}),new s({name:"RightTriangeChamferSimple",input:{value:new N(1),type:new Y("chamfer"),toolRadius:new L(0)},className:ot}),new s({name:"RightTriangeCtypeChamfer",input:{quadrant:new V,pointC:new y(new i({x:100,z:0})),angleA:new q(45),valueType:new k("Uhalf"),value:new N(1),direction:new _("逆时针"),position:new M("外侧"),toolRadius:new L(0)},className:ht}),new s({name:"RightTriangeRtypeChamfer",input:{quadrant:new V,pointC:new y(new i({x:100,z:0})),valueType:new k("Uhalf"),value:new Z(1),direction:new _("逆时针"),position:new M("外侧"),toolRadius:new L(0)},className:rt}),new s({name:"G90",input:{startPoint:new y(new i({x:100,z:0})),endPoint:new y(new i({x:120,z:-20})),startExtendLength:new P,endExtendLength:new P,toolRadius:new L(0)},className:lt}),new s({name:"G94",input:{startPoint:new y(new i({x:100,z:0})),endPoint:new y(new i({x:120,z:-20})),startExtendLength:new P,endExtendLength:new P,toolRadius:new L(0)},className:dt})];return(a,n)=>(U(),G(nt,null,st(t,o=>j(et,{data:o,displayHader:!0},null,8,["data"])),64))}}),Bt=JSON.parse('{"title":"Calculator","description":"","frontmatter":{},"headers":[],"relativePath":"pages/lathe/Calculator.md","filePath":"pages/lathe/Calculator.md"}'),ut={name:"pages/lathe/Calculator.md"},mt=Object.assign(ut,{setup(d){return(s,t)=>(U(),G("div",{"data-pagefind-body":!0},[t[0]||(t[0]=z("h1",{id:"calculator",tabindex:"-1"},[at("Calculator "),z("a",{class:"header-anchor",href:"#calculator","aria-label":'Permalink to "Calculator"'},"​")],-1)),t[1]||(t[1]=z("p",null,"This is a calculator component.",-1)),j(ct)]))}});export{Bt as __pageData,mt as default};
